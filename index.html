<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Arena P2P - Local Network Multiplayer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Press Start 2P', cursive; 
            background: #0f0f0f;
            overflow: hidden;
            color: white;
        }
        
        #game-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        
        .ui-layer.interactive {
            pointer-events: auto;
        }
        
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .screen.hidden { display: none !important; }
        
        .title {
            font-size: 2.5rem;
            color: #fbbf24;
            text-shadow: 4px 4px 0 #000;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            color: #60a5fa;
            font-size: 0.8rem;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.8;
        }
        
        .btn {
            background: #fbbf24;
            color: #000;
            border: 4px solid #fff;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 6px 0 #b45309;
            transition: all 0.1s;
            pointer-events: auto;
        }
        
        .btn:hover { transform: scale(1.05); }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #b45309; }
        .btn.secondary { background: #3b82f6; box-shadow: 0 6px 0 #1e40af; }
        .btn.danger { background: #ef4444; box-shadow: 0 6px 0 #991b1b; }
        
        .connection-box {
            background: rgba(0,0,0,0.7);
            border: 2px solid #60a5fa;
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
            margin: 20px 0;
        }
        
        .code-display {
            background: #000;
            border: 2px solid #fbbf24;
            padding: 15px;
            font-family: monospace;
            font-size: 0.7rem;
            color: #fbbf24;
            word-break: break-all;
            margin: 10px 0;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .input-field {
            width: 100%;
            padding: 10px;
            font-family: monospace;
            font-size: 0.7rem;
            background: #1a1a1a;
            border: 2px solid #60a5fa;
            color: #fff;
            margin: 10px 0;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-offline { background: #ef4444; }
        .status-connecting { background: #fbbf24; animation: blink 1s infinite; }
        .status-online { background: #22c55e; }
        
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        
        .players-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            pointer-events: none;
        }
        
        .player-card {
            background: rgba(0,0,0,0.8);
            border: 3px solid;
            padding: 10px 15px;
            border-radius: 8px;
            min-width: 140px;
        }
        
        .player-name { font-size: 0.7rem; margin-bottom: 5px; }
        .hp-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        .hp-fill { height: 100%; transition: width 0.2s; }
        
        .deaths { 
            font-size: 0.6rem; 
            color: #ef4444; 
            margin-top: 5px;
        }
        
        .ultimate-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }
        .ultimate-fill {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            width: 0%;
            transition: width 0.3s;
        }
        
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            font-size: 0.6rem;
            line-height: 1.8;
        }
        
        .kill-feed {
            position: fixed;
            top: 150px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-end;
        }
        
        .kill-msg {
            background: rgba(0,0,0,0.9);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.6rem;
            animation: slideIn 0.3s;
            border-left: 3px solid #ef4444;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #fbbf24;
            z-index: 50;
        }
        
        .error-msg {
            color: #ef4444;
            font-size: 0.7rem;
            margin: 10px 0;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- Canvas -->
    <canvas id="game-canvas"></canvas>

    <!-- Loading -->
    <div id="loading" class="loading hidden">LOADING...</div>

    <!-- Main Menu -->
    <div id="main-menu" class="screen">
        <div class="title">VOXEL ARENA</div>
        <div class="subtitle">
            LOCAL NETWORK MULTIPLAYER<br>
            2-4 Players • Last Stand Wins<br>
            3 Deaths = Ultimate • 5 Deaths = ELIMINATED
        </div>
        
        <button class="btn" onclick="showHostMenu()">HOST GAME</button>
        <button class="btn secondary" onclick="showJoinMenu()">JOIN GAME</button>
        <button class="btn" onclick="showControls()">CONTROLS</button>
    </div>

    <!-- Host Menu -->
    <div id="host-menu" class="screen hidden">
        <div class="title">HOST GAME</div>
        <div class="subtitle">Create a room for others to join</div>
        
        <div class="connection-box">
            <div style="margin-bottom: 15px;">
                <span class="status-indicator" id="host-status"></span>
                <span id="host-status-text">Offline</span>
            </div>
            
            <div style="font-size: 0.7rem; margin-bottom: 10px;">Your Room Code (share this):</div>
            <div class="code-display" id="host-code">Click "CREATE ROOM" to generate code</div>
            
            <button class="btn" onclick="createRoom()" id="create-btn">CREATE ROOM</button>
            <button class="btn secondary hidden" onclick="startHostedGame()" id="start-btn">START GAME</button>
        </div>
        
        <div class="connection-box">
            <div style="font-size: 0.7rem; margin-bottom: 10px;">Connected Players:</div>
            <div id="connected-players" style="font-size: 0.7rem; color: #60a5fa;">None</div>
        </div>
        
        <button class="btn danger" onclick="showMenu()">BACK</button>
    </div>

    <!-- Join Menu -->
    <div id="join-menu" class="screen hidden">
        <div class="title">JOIN GAME</div>
        <div class="subtitle">Enter the room code from host</div>
        
        <div class="connection-box">
            <div style="margin-bottom: 15px;">
                <span class="status-indicator" id="join-status"></span>
                <span id="join-status-text">Offline</span>
            </div>
            
            <div style="font-size: 0.7rem; margin-bottom: 10px;">Enter Room Code:</div>
            <textarea class="input-field" id="join-code" rows="3" placeholder="Paste room code here..."></textarea>
            
            <button class="btn" onclick="joinRoom()" id="join-btn">CONNECT</button>
        </div>
        
        <div id="join-error" class="error-msg hidden"></div>
        
        <button class="btn danger" onclick="showMenu()">BACK</button>
    </div>

    <!-- Controls -->
    <div id="controls-screen" class="screen hidden">
        <div class="title" style="font-size: 1.8rem;">CONTROLS</div>
        
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; max-width: 800px; padding: 20px;">
            <div class="connection-box">
                <div style="color: #3b82f6; margin-bottom: 10px;">MOVEMENT</div>
                <div style="font-size: 0.7rem; line-height: 2;">
                    W A S D or ARROWS = Move<br>
                    SPACE = Jump<br>
                    Mouse = Camera (if enabled)
                </div>
            </div>
            <div class="connection-box">
                <div style="color: #ef4444; margin-bottom: 10px;">COMBAT</div>
                <div style="font-size: 0.7rem; line-height: 2;">
                    F or LEFT CLICK = Attack<br>
                    G or RIGHT CLICK = Ultimate (when charged)<br>
                    3 Deaths = Ultimate Charge<br>
                    5 Deaths = ELIMINATED
                </div>
            </div>
        </div>
        
        <button class="btn" onclick="showMenu()">BACK</button>
    </div>

    <!-- Game HUD -->
    <div id="game-hud" class="ui-layer hidden">
        <div class="players-hud" id="players-hud"></div>
        <div class="kill-feed" id="kill-feed"></div>
        <div class="controls-hint" id="controls-hint">
            WASD = Move | SPACE = Jump | F = Attack | G = Ultimate
        </div>
    </div>

    <!-- Game Over -->
    <div id="game-over" class="screen hidden">
        <div class="title" id="winner-title" style="color: #fbbf24;">GAME OVER</div>
        <div class="subtitle" id="winner-subtitle">Player 1 Wins!</div>
        <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

<script>
/**
 * P2P MULTIPLAYER GAME WITH WEBRTC
 * Works on local network without central server
 */

// ==================== CONFIG ====================
const CONFIG = {
    chunkSize: 40,
    viewDistance: 3,
    maxDeaths: 5,
    ultimateDeaths: 3,
    respawnTime: 3,
    playerSpeed: 10,
    playerRunSpeed: 18,
    jumpForce: 15,
    gravity: 35,
    colors: [0x3b82f6, 0xef4444, 0x22c55e, 0xa855f7, 0xf59e0b, 0xec4899]
};

// ==================== GLOBALS ====================
let canvas, ctx; // 2D fallback if WebGL fails
let scene, camera, renderer;
let simplex = new SimplexNoise();
let clock = new THREE.Clock();
let chunks = new Map();
let particles = [];

// Network
let peerConnection = null;
let dataChannel = null;
let isHost = false;
let myPlayerId = 0;
let connected = false;

// Game State
let players = new Map(); // id -> player object
let localPlayer = null;
let gameActive = false;
let entities = [];

// Input
const keys = {};
const mouse = { x: 0, y: 0, down: false, rightDown: false };

// ==================== INITIALIZATION ====================

function init() {
    // Try WebGL first
    try {
        canvas = document.getElementById('game-canvas');
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.shadowMap.enabled = true;
        
        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);
        
        console.log("WebGL initialized successfully");
        
    } catch(e) {
        console.error("WebGL failed:", e);
        alert("WebGL not supported! Please use a modern browser.");
        return;
    }
    
    // Events
    window.addEventListener('resize', onResize);
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup', e => { keys[e.code] = false; });
    document.addEventListener('mousedown', e => {
        if(e.button === 0) mouse.down = true;
        if(e.button === 2) mouse.rightDown = true;
    });
    document.addEventListener('mouseup', e => {
        if(e.button === 0) mouse.down = false;
        if(e.button === 2) mouse.rightDown = false;
    });
    document.addEventListener('contextmenu', e => e.preventDefault());
    
    // Show menu
    showMenu();
}

// ==================== UI FUNCTIONS ====================

function showMenu() {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('main-menu').classList.remove('hidden');
    document.getElementById('game-hud').classList.add('hidden');
}

function showHostMenu() {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('host-menu').classList.remove('hidden');
    updateHostStatus('offline');
}

function showJoinMenu() {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('join-menu').classList.remove('hidden');
    updateJoinStatus('offline');
}

function showControls() {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('controls-screen').classList.remove('hidden');
}

function updateHostStatus(status) {
    const indicator = document.getElementById('host-status');
    const text = document.getElementById('host-status-text');
    
    indicator.className = 'status-indicator';
    if(status === 'offline') {
        indicator.classList.add('status-offline');
        text.innerText = 'Offline';
    } else if(status === 'connecting') {
        indicator.classList.add('status-connecting');
        text.innerText = 'Creating...';
    } else if(status === 'online') {
        indicator.classList.add('status-online');
        text.innerText = 'Room Created - Waiting for players';
    }
}

function updateJoinStatus(status, msg = '') {
    const indicator = document.getElementById('join-status');
    const text = document.getElementById('join-status-text');
    const error = document.getElementById('join-error');
    
    indicator.className = 'status-indicator';
    error.classList.add('hidden');
    
    if(status === 'offline') {
        indicator.classList.add('status-offline');
        text.innerText = 'Offline';
    } else if(status === 'connecting') {
        indicator.classList.add('status-connecting');
        text.innerText = 'Connecting...';
    } else if(status === 'online') {
        indicator.classList.add('status-online');
        text.innerText = 'Connected!';
    } else if(status === 'error') {
        indicator.classList.add('status-offline');
        text.innerText = 'Error';
        error.innerText = msg;
        error.classList.remove('hidden');
    }
}

// ==================== WEBRTC P2P NETWORKING ====================

// Using public STUN servers for NAT traversal
const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' }
    ]
};

function createRoom() {
    isHost = true;
    myPlayerId = 0;
    updateHostStatus('connecting');
    
    peerConnection = new RTCPeerConnection(iceServers);
    
    // Create data channel
    dataChannel = peerConnection.createDataChannel('game', {
        ordered: true
    });
    
    setupDataChannel(dataChannel);
    
    // Handle ICE candidates
    peerConnection.onicecandidate = event => {
        if(event.candidate) {
            // In real app, send this to peer via signaling server
            // For local network, we collect all candidates
        }
    };
    
    // Create offer
    peerConnection.createOffer()
        .then(offer => peerConnection.setLocalDescription(offer))
        .then(() => {
            // Display the offer for copy-paste signaling
            const offerCode = btoa(JSON.stringify(peerConnection.localDescription));
            document.getElementById('host-code').innerText = offerCode;
            updateHostStatus('online');
            document.getElementById('create-btn').classList.add('hidden');
            document.getElementById('start-btn').classList.remove('hidden');
            
            // Also set up to receive answer
            window.currentOffer = peerConnection.localDescription;
        })
        .catch(err => {
            console.error(err);
            updateHostStatus('offline');
            alert('Failed to create room: ' + err.message);
        });
    
    // Handle connection
    peerConnection.ondatachannel = event => {
        const channel = event.channel;
        setupDataChannel(channel);
    };
}

function joinRoom() {
    const code = document.getElementById('join-code').value.trim();
    if(!code) {
        updateJoinStatus('error', 'Please enter a room code');
        return;
    }
    
    isHost = false;
    updateJoinStatus('connecting');
    
    try {
        const offer = JSON.parse(atob(code));
        
        peerConnection = new RTCPeerConnection(iceServers);
        
        peerConnection.ondatachannel = event => {
            dataChannel = event.channel;
            setupDataChannel(dataChannel);
        };
        
        peerConnection.setRemoteDescription(offer)
            .then(() => peerConnection.createAnswer())
            .then(answer => peerConnection.setLocalDescription(answer))
            .then(() => {
                // Display answer for host
                const answerCode = btoa(JSON.stringify(peerConnection.localDescription));
                alert('Copy this answer code and send to host:\n\n' + answerCode.substring(0, 100) + '...');
                
                // Wait for host to input answer
                const hostAnswer = prompt('Paste host answer code:');
                if(hostAnswer) {
                    const answer = JSON.parse(atob(hostAnswer));
                    peerConnection.setRemoteDescription(answer);
                }
            });
            
    } catch(e) {
        updateJoinStatus('error', 'Invalid room code');
        console.error(e);
    }
}

// For host to accept answer
function acceptAnswer() {
    const answerCode = prompt('Paste the answer code from joining player:');
    if(!answerCode) return;
    
    try {
        const answer = JSON.parse(atob(answerCode));
        peerConnection.setRemoteDescription(answer);
    } catch(e) {
        alert('Invalid answer code');
    }
}

function setupDataChannel(channel) {
    channel.onopen = () => {
        console.log('Data channel open!');
        connected = true;
        
        if(isHost) {
            document.getElementById('connected-players').innerText = '1 player connected';
        } else {
            updateJoinStatus('online');
            // Request to join game
            sendMessage({ type: 'join', name: 'Player ' + Math.floor(Math.random() * 1000) });
        }
    };
    
    channel.onmessage = event => {
        const msg = JSON.parse(event.data);
        handleNetworkMessage(msg);
    };
    
    channel.onclose = () => {
        console.log('Data channel closed');
        connected = false;
    };
}

function sendMessage(msg) {
    if(dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify(msg));
    }
}

function handleNetworkMessage(msg) {
    switch(msg.type) {
        case 'join':
            if(isHost) {
                const newId = players.size + 1;
                sendMessage({ type: 'welcome', id: newId, hostId: myPlayerId });
                addRemotePlayer(newId);
            }
            break;
        case 'welcome':
            myPlayerId = msg.id;
            addLocalPlayer();
            addRemotePlayer(msg.hostId);
            break;
        case 'playerState':
            updateRemotePlayer(msg.id, msg.data);
            break;
        case 'attack':
            handleRemoteAttack(msg.id, msg.data);
            break;
        case 'damage':
            applyDamage(msg.target, msg.damage, msg.source);
            break;
        case 'death':
            handleRemoteDeath(msg.id, msg.killer);
            break;
        case 'startGame':
            startGame();
            break;
    }
}

// ==================== PLAYER SYSTEM ====================

function addLocalPlayer() {
    localPlayer = createPlayerObject(myPlayerId, true);
    players.set(myPlayerId, localPlayer);
}

function addRemotePlayer(id) {
    if(!players.has(id)) {
        const player = createPlayerObject(id, false);
        players.set(id, player);
    }
}

function createPlayerObject(id, isLocal) {
    const group = new THREE.Group();
    const color = CONFIG.colors[id % CONFIG.colors.length];
    
    // Body
    const bodyGeo = new THREE.BoxGeometry(1, 1.2, 0.6);
    const bodyMat = new THREE.MeshStandardMaterial({ color: color });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.6;
    body.castShadow = true;
    group.add(body);
    
    // Head
    const headGeo = new THREE.BoxGeometry(0.7, 0.7, 0.7);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.6;
    head.castShadow = true;
    group.add(head);
    
    // Eyes
    const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.1);
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEye.position.set(-0.15, 1.6, 0.4);
    group.add(leftEye);
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    rightEye.position.set(0.15, 1.6, 0.4);
    group.add(rightEye);
    
    // Arms
    const armGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
    const leftArm = new THREE.Mesh(armGeo, bodyMat);
    leftArm.position.set(-0.7, 0.8, 0);
    group.add(leftArm);
    
    const rightArmGroup = new THREE.Group();
    rightArmGroup.position.set(0.7, 1.2, 0);
    const rightArm = new THREE.Mesh(armGeo, bodyMat);
    rightArm.position.set(0, -0.4, 0);
    rightArmGroup.add(rightArm);
    group.add(rightArmGroup);
    
    // Weapon
    const weaponGeo = new THREE.BoxGeometry(0.1, 1.4, 0.1);
    const weaponMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
    const weapon = new THREE.Mesh(weaponGeo, weaponMat);
    weapon.position.set(0, -0.5, 0.3);
    weapon.rotation.x = Math.PI / 2;
    weapon.visible = false;
    rightArm.add(weapon);
    
    // Name tag
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('P' + (id + 1), 64, 22);
    
    const tex = new THREE.CanvasTexture(canvas);
    const spriteMat = new THREE.SpriteMaterial({ map: tex });
    const sprite = new THREE.Sprite(spriteMat);
    sprite.position.y = 2.5;
    sprite.scale.set(1.5, 0.4, 1);
    group.add(sprite);
    
    scene.add(group);
    
    // Random spawn
    const angle = (Math.PI * 2 / 4) * id;
    group.position.set(Math.cos(angle) * 20, 10, Math.sin(angle) * 20);
    
    return {
        id: id,
        mesh: group,
        isLocal: isLocal,
        hp: 100,
        maxHp: 100,
        deaths: 0,
        ultimateCharge: 0,
        isDead: false,
        velocity: new THREE.Vector3(),
        speed: 0,
        isJumping: false,
        isAttacking: false,
        attackCooldown: 0,
        rightArm: rightArmGroup,
        weapon: weapon,
        color: color
    };
}

function updateRemotePlayer(id, data) {
    const player = players.get(id);
    if(player && !player.isLocal) {
        player.mesh.position.set(data.x, data.y, data.z);
        player.mesh.rotation.y = data.rot;
        player.hp = data.hp;
        player.deaths = data.deaths;
        
        if(data.attacking) {
            player.weapon.visible = true;
            player.rightArm.rotation.x = -Math.PI / 2;
        } else {
            player.rightArm.rotation.x = 0;
        }
    }
}

// ==================== GAME LOOP ====================

function startHostedGame() {
    sendMessage({ type: 'startGame' });
    startGame();
}

function startGame() {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('game-hud').classList.remove('hidden');
    
    if(!localPlayer) {
        addLocalPlayer();
    }
    
    gameActive = true;
    createHUD();
    animate();
}

function createHUD() {
    const container = document.getElementById('players-hud');
    container.innerHTML = '';
    
    players.forEach(p => {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.id = 'card-' + p.id;
        card.style.borderColor = '#' + p.color.toString(16).padStart(6, '0');
        card.innerHTML = `
            <div class="player-name" style="color: #${p.color.toString(16).padStart(6, '0')}">P${p.id + 1} ${p.isLocal ? '(YOU)' : ''}</div>
            <div class="hp-bar"><div class="hp-fill" id="hp-${p.id}" style="width: 100%; background: #${p.color.toString(16).padStart(6, '0')}"></div></div>
            <div class="ultimate-bar"><div class="ultimate-fill" id="ult-${p.id}"></div></div>
            <div class="deaths" id="deaths-${p.id}">Deaths: 0/5</div>
        `;
        container.appendChild(card);
    });
}

function updateHUD() {
    players.forEach(p => {
        const hpBar = document.getElementById('hp-' + p.id);
        const ultBar = document.getElementById('ult-' + p.id);
        const deaths = document.getElementById('deaths-' + p.id);
        const card = document.getElementById('card-' + p.id);
        
        if(hpBar) hpBar.style.width = (p.hp / p.maxHp * 100) + '%';
        if(ultBar) ultBar.style.width = (p.ultimateCharge / CONFIG.ultimateDeaths * 100) + '%';
        if(deaths) deaths.innerText = `Deaths: ${p.deaths}/${CONFIG.maxDeaths}`;
        
        if(p.isDead && card) {
            card.style.opacity = '0.3';
        } else if(card) {
            card.style.opacity = '1';
        }
        
        if(p.ultimateCharge >= CONFIG.ultimateDeaths && card && p.isLocal) {
            card.style.boxShadow = '0 0 20px #fbbf24';
        }
    });
}

function getTerrainHeight(x, z) {
    return simplex.noise2D(x * 0.02, z * 0.02) * 5;
}

function generateChunk(cx, cz) {
    const key = `${cx},${cz}`;
    if(chunks.has(key)) return;

    const geometry = new THREE.PlaneGeometry(CONFIG.chunkSize, CONFIG.chunkSize, 20, 20);
    geometry.rotateX(-Math.PI / 2);
    
    const pos = geometry.attributes.position;
    for(let i=0; i<pos.count; i++) {
        const wx = pos.getX(i) + (cx * CONFIG.chunkSize);
        const wz = pos.getZ(i) + (cz * CONFIG.chunkSize);
        pos.setY(i, getTerrainHeight(wx, wz));
    }
    geometry.computeVertexNormals();

    const material = new THREE.MeshStandardMaterial({ color: 0x3a5f0b, flatShading: true });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(cx * CONFIG.chunkSize, 0, cz * CONFIG.chunkSize);
    mesh.receiveShadow = true;
    
    scene.add(mesh);
    chunks.set(key, mesh);
}

// ==================== UPDATE ====================

function update(dt) {
    if(!gameActive) return;
    
    // Update local player
    if(localPlayer && !localPlayer.isDead) {
        updateLocalPlayer(dt);
    }
    
    // Camera follows local player
    if(localPlayer) {
        const target = localPlayer.mesh.position.clone();
        target.y += 15;
        const offset = new THREE.Vector3(0, 10, -20).applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.mesh.rotation.y);
        camera.position.lerp(target.add(offset), 0.1);
        camera.lookAt(localPlayer.mesh.position);
    }
    
    // Update chunks
    if(localPlayer) {
        const cx = Math.floor(localPlayer.mesh.position.x / CONFIG.chunkSize);
        const cz = Math.floor(localPlayer.mesh.position.z / CONFIG.chunkSize);
        for(let x=cx-2; x<=cx+2; x++) {
            for(let z=cz-2; z<=cz+2; z++) {
                generateChunk(x, z);
            }
        }
    }
    
    // Send network update
    if(localPlayer && Math.random() < 0.3) { // 10fps network update
        sendMessage({
            type: 'playerState',
            id: myPlayerId,
            data: {
                x: localPlayer.mesh.position.x,
                y: localPlayer.mesh.position.y,
                z: localPlayer.mesh.position.z,
                rot: localPlayer.mesh.rotation.y,
                hp: localPlayer.hp,
                deaths: localPlayer.deaths,
                attacking: localPlayer.isAttacking
            }
        });
    }
    
    updateHUD();
}

function updateLocalPlayer(dt) {
    const p = localPlayer;
    
    // Movement
    let moving = false;
    const targetSpeed = keys['ShiftLeft'] ? CONFIG.playerRunSpeed : CONFIG.playerSpeed;
    
    if(keys['KeyW'] || keys['ArrowUp']) {
        p.speed = Math.min(p.speed + 50*dt, targetSpeed);
        moving = true;
    } else if(keys['KeyS'] || keys['ArrowDown']) {
        p.speed = Math.max(p.speed - 50*dt, -targetSpeed*0.5);
        moving = true;
    } else {
        p.speed = THREE.MathUtils.lerp(p.speed, 0, 10*dt);
    }
    
    if(keys['KeyA'] || keys['ArrowLeft']) p.mesh.rotation.y += 3*dt;
    if(keys['KeyD'] || keys['ArrowRight']) p.mesh.rotation.y -= 3*dt;
    
    p.velocity.x = Math.sin(p.mesh.rotation.y) * p.speed;
    p.velocity.z = Math.cos(p.mesh.rotation.y) * p.speed;
    
    p.mesh.position.x += p.velocity.x * dt;
    p.mesh.position.z += p.velocity.z * dt;
    
    // Physics
    const groundH = getTerrainHeight(p.mesh.position.x, p.mesh.position.z);
    
    if((keys['Space'] || keys['Numpad0']) && !p.isJumping) {
        p.velocity.y = CONFIG.jumpForce;
        p.isJumping = true;
    }
    
    if(p.isJumping) {
        p.velocity.y -= CONFIG.gravity * dt;
        p.mesh.position.y += p.velocity.y * dt;
        if(p.mesh.position.y <= groundH + 1.1) {
            p.mesh.position.y = groundH + 1.1;
            p.isJumping = false;
            p.velocity.y = 0;
        }
    } else {
        p.mesh.position.y = groundH + 1.1;
    }
    
    // Attack
    if(p.attackCooldown > 0) p.attackCooldown -= dt;
    
    if((keys['KeyF'] || mouse.down) && p.attackCooldown <= 0 && !p.isAttacking) {
        performAttack();
        keys['KeyF'] = false;
        mouse.down = false;
    }
    
    // Ultimate
    if((keys['KeyG'] || mouse.rightDown) && p.ultimateCharge >= CONFIG.ultimateDeaths) {
        performUltimate();
        keys['KeyG'] = false;
        mouse.rightDown = false;
    }
    
    // Animation
    if(Math.abs(p.speed) > 1) {
        const time = Date.now() * 0.01;
        p.mesh.children[2].rotation.x = Math.sin(time) * 0.5;
        if(!p.isAttacking) {
            p.rightArm.rotation.x = Math.sin(time + Math.PI) * 0.5;
        }
    } else if(!p.isAttacking) {
        p.rightArm.rotation.x = 0;
    }
}

function performAttack() {
    const p = localPlayer;
    p.isAttacking = true;
    p.attackCooldown = 0.4;
    p.weapon.visible = true;
    
    // Animation
    let swing = 0;
    const anim = setInterval(() => {
        swing += 0.3;
        p.rightArm.rotation.x = -Math.PI/2 + Math.sin(swing) * 0.5;
        if(swing > Math.PI) {
            clearInterval(anim);
            p.isAttacking = false;
            p.weapon.visible = false;
            p.rightArm.rotation.x = 0;
        }
    }, 16);
    
    // Check hits
    sendMessage({ type: 'attack', id: myPlayerId, data: { x: p.mesh.position.x, z: p.mesh.position.z, rot: p.mesh.rotation.y } });
    
    // Local hit detection
    players.forEach(target => {
        if(target.id !== myPlayerId && !target.isDead) {
            const dist = p.mesh.position.distanceTo(target.mesh.position);
            if(dist < 3) {
                const toTarget = new THREE.Vector3().subVectors(target.mesh.position, p.mesh.position).normalize();
                const facing = new THREE.Vector3(Math.sin(p.mesh.rotation.y), 0, Math.cos(p.mesh.rotation.y));
                if(facing.dot(toTarget) > 0.3) {
                    sendMessage({ type: 'damage', target: target.id, damage: 20, source: myPlayerId });
                }
            }
        }
    });
}

function performUltimate() {
    const p = localPlayer;
    p.ultimateCharge = 0;
    
    // AOE effect
    sendMessage({ type: 'ultimate', id: myPlayerId, pos: { x: p.mesh.position.x, z: p.mesh.position.z } });
    
    players.forEach(target => {
        if(target.id !== myPlayerId && !target.isDead) {
            const dist = p.mesh.position.distanceTo(target.mesh.position);
            if(dist < 10) {
                sendMessage({ type: 'damage', target: target.id, damage: 40, source: myPlayerId });
            }
        }
    });
    
    // Visual
    createExplosion(p.mesh.position, 0xfbbf24, 20);
    addKillFeed('P' + (myPlayerId + 1) + ' used ULTIMATE!');
}

function applyDamage(targetId, damage, sourceId) {
    const target = players.get(targetId);
    if(!target || target.isDead) return;
    
    target.hp -= damage;
    
    // Flash effect
    target.mesh.children[0].material.emissive.setHex(0xffffff);
    target.mesh.children[0].material.emissiveIntensity = 0.5;
    setTimeout(() => {
        target.mesh.children[0].material.emissive.setHex(0x000000);
        target.mesh.children[0].material.emissiveIntensity = 0;
    }, 100);
    
    if(target.hp <= 0) {
        handleDeath(target, sourceId);
    }
}

function handleDeath(player, killerId) {
    player.deaths++;
    player.ultimateCharge = Math.min(player.ultimateCharge + 1, CONFIG.ultimateDeaths);
    
    const killer = players.get(killerId);
    if(killer) {
        killer.kills = (killer.kills || 0) + 1;
        killer.ultimateCharge = Math.min(killer.ultimateCharge + 0.5, CONFIG.ultimateDeaths);
    }
    
    addKillFeed('P' + (killerId + 1) + ' killed P' + (player.id + 1));
    
    if(player.deaths >= CONFIG.maxDeaths) {
        player.isDead = true;
        player.mesh.visible = false;
        addKillFeed('P' + (player.id + 1) + ' ELIMINATED!');
        checkWinner();
    } else {
        // Respawn
        setTimeout(() => {
            player.hp = player.maxHp;
            const angle = Math.random() * Math.PI * 2;
            player.mesh.position.set(Math.cos(angle) * 30, 15, Math.sin(angle) * 30);
        }, 2000);
    }
    
    if(player.isLocal) {
        sendMessage({ type: 'death', id: player.id, killer: killerId });
    }
}

function checkWinner() {
    const alive = Array.from(players.values()).filter(p => !p.isDead);
    if(alive.length === 1 && players.size > 1) {
        gameActive = false;
        document.getElementById('game-hud').classList.add('hidden');
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('winner-title').innerText = 'P' + (alive[0].id + 1) + ' WINS!';
    }
}

function createExplosion(pos, color, count) {
    for(let i=0; i<count; i++) {
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        scene.add(mesh);
        
        particles.push({
            mesh: mesh,
            vel: new THREE.Vector3((Math.random()-0.5)*10, Math.random()*10, (Math.random()-0.5)*10),
            life: 1.0
        });
    }
}

function addKillFeed(msg) {
    const feed = document.getElementById('kill-feed');
    const el = document.createElement('div');
    el.className = 'kill-msg';
    el.innerText = msg;
    feed.appendChild(el);
    setTimeout(() => el.remove(), 3000);
}

function animate() {
    requestAnimationFrame(animate);
    
    const dt = Math.min(clock.getDelta(), 0.1);
    update(dt);
    
    // Update particles
    for(let i=particles.length-1; i>=0; i--) {
        const p = particles[i];
        p.life -= dt;
        p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
        p.vel.y -= 20 * dt;
        if(p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
        }
    }
    
    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Start
window.onload = init;

</script>
</body>
</html>