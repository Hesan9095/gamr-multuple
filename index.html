<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Arena - Working Version</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Press Start 2P', cursive; 
            background: #0a0a0a;
            color: white;
            overflow: hidden;
        }
        
        #game-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
            display: block;
        }
        
        .screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 20px;
        }
        
        .hidden { display: none !important; }
        
        .title {
            font-size: 2.5rem;
            color: #fbbf24;
            text-shadow: 0 0 20px #fbbf24, 4px 4px 0 #000;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            color: #60a5fa;
            font-size: 0.6rem;
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.8;
        }
        
        .btn {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #000;
            border: none;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 0.9rem;
            cursor: pointer;
            margin: 10px;
            border-radius: 10px;
            box-shadow: 0 6px 0 #92400e;
            transition: all 0.1s;
            font-weight: bold;
        }
        
        .btn:hover { transform: translateY(-2px); }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #92400e; }
        .btn.secondary { background: linear-gradient(135deg, #3b82f6, #2563eb); box-shadow: 0 6px 0 #1e40af; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        
        .step-box {
            background: rgba(0,0,0,0.6);
            border: 2px solid #60a5fa;
            border-radius: 15px;
            padding: 20px;
            max-width: 600px;
            width: 100%;
            margin: 10px 0;
        }
        
        .code-box {
            background: #000;
            border: 2px solid #22c55e;
            border-radius: 10px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.5rem;
            color: #22c55e;
            word-break: break-all;
            max-height: 100px;
            overflow-y: auto;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .code-input {
            width: 100%;
            background: #000;
            border: 2px solid #60a5fa;
            border-radius: 10px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.5rem;
            color: #fff;
            min-height: 100px;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.6rem;
        }
        
        .status-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: #ef4444;
        }
        .status-dot.connecting { background: #fbbf24; animation: blink 1s infinite; }
        .status-dot.connected { background: #22c55e; }
        
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        
        .players-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
        }
        
        .player-card {
            background: rgba(0,0,0,0.85);
            border: 3px solid;
            border-radius: 10px;
            padding: 10px 15px;
            min-width: 140px;
        }
        
        .hp-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        .hp-fill { height: 100%; }
        
        .kill-feed {
            position: fixed;
            top: 140px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }
        
        .kill-msg {
            background: rgba(0,0,0,0.9);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.6rem;
            border-left: 3px solid #ef4444;
        }
        
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 0.55rem;
            text-align: center;
            line-height: 1.6;
            z-index: 10;
        }
        
        .error-message {
            color: #ef4444;
            font-size: 0.6rem;
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- Error Display -->
    <div id="error-display" class="error-message hidden" style="position: fixed; top: 10px; left: 10px; right: 10px; z-index: 200;"></div>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen">
        <div class="title">‚öîÔ∏è VOXEL ARENA</div>
        <div class="subtitle">
            SYNCHRONIZED TERRAIN MULTIPLAYER<br>
            Both players see the EXACT same world<br>
            2 Players ‚Ä¢ 5 Deaths = Elimination
        </div>
        <button class="btn" onclick="startHost()">üéÆ HOST GAME</button>
        <button class="btn secondary" onclick="startJoin()">üöÄ JOIN GAME</button>
    </div>

    <!-- HOST SCREEN -->
    <div id="host-screen" class="screen hidden">
        <div class="title" style="font-size: 1.8rem;">HOST GAME</div>
        
        <div class="step-box">
            <div style="font-size: 0.7rem; margin-bottom: 10px;">
                <span style="color: #fbbf24;">Step 1:</span> Copy this code and send to friend:
            </div>
            <div class="code-box" id="host-offer" onclick="copyText(this)">Click CREATE OFFER</div>
            <button class="btn" id="create-offer-btn" onclick="createHostOffer()">CREATE OFFER</button>
        </div>
        
        <div class="step-box">
            <div style="font-size: 0.7rem; margin-bottom: 10px;">
                <span style="color: #fbbf24;">Step 2:</span> Paste friend's answer:
            </div>
            <textarea class="code-input" id="host-answer-input" placeholder="Paste answer code here..."></textarea>
            <button class="btn" onclick="hostAcceptAnswer()">START GAME</button>
        </div>
        
        <div class="status">
            <div class="status-dot" id="host-status-dot"></div>
            <span id="host-status-text">Ready</span>
        </div>
        
        <button class="btn secondary" onclick="backToMenu()">BACK</button>
    </div>

    <!-- JOIN SCREEN -->
    <div id="join-screen" class="screen hidden">
        <div class="title" style="font-size: 1.8rem;">JOIN GAME</div>
        
        <div class="step-box">
            <div style="font-size: 0.7rem; margin-bottom: 10px;">
                <span style="color: #60a5fa;">Step 1:</span> Paste host's code:
            </div>
            <textarea class="code-input" id="join-offer-input" placeholder="Paste offer code here..."></textarea>
            <button class="btn" onclick="createJoinAnswer()">CREATE ANSWER</button>
        </div>
        
        <div class="step-box hidden" id="join-answer-box">
            <div style="font-size: 0.7rem; margin-bottom: 10px;">
                <span style="color: #22c55e;">Step 2:</span> Copy this to host:
            </div>
            <div class="code-box" id="join-answer" onclick="copyText(this)">...</div>
        </div>
        
        <div class="status">
            <div class="status-dot" id="join-status-dot"></div>
            <span id="join-status-text">Enter code</span>
        </div>
        
        <button class="btn secondary" onclick="backToMenu()">BACK</button>
    </div>

    <!-- GAME HUD -->
    <div id="game-hud" class="hidden">
        <div class="players-hud" id="players-hud"></div>
        <div class="kill-feed" id="kill-feed"></div>
        <div class="controls-hint">
            <span style="color: #fbbf24;">WASD</span> = Move | 
            <span style="color: #fbbf24;">SPACE</span> = Jump | 
            <span style="color: #ef4444;">F / CLICK</span> = Attack | 
            <span style="color: #fbbf24;">G / RIGHT-CLICK</span> = Ultimate
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over" class="screen hidden">
        <div class="title" id="winner-title">VICTORY!</div>
        <div class="subtitle" id="winner-subtitle">Player Wins!</div>
        <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

<script>
// ==================== DETERMINISTIC RANDOM (No external lib) ====================

// Simple seeded random number generator
function createSeededRandom(seed) {
    let s = seed;
    return function() {
        s = Math.sin(s * 12.9898 + 78.233) * 43758.5453;
        return s - Math.floor(s);
    };
}

// Use fixed seed for terrain
const TERRAIN_SEED = 12345;
const seededRandom = createSeededRandom(TERRAIN_SEED);

// Simplex-like noise using seeded random
function createNoise() {
    const perm = [];
    for(let i = 0; i < 256; i++) perm[i] = Math.floor(seededRandom() * 256);
    for(let i = 0; i < 256; i++) perm[256 + i] = perm[i];
    
    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(t, a, b) { return a + t * (b - a); }
    function grad(hash, x, y) {
        const h = hash & 15;
        const u = h < 8 ? x : y;
        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
    }
    
    return {
        noise2D: function(x, y) {
            const X = Math.floor(x) & 255;
            const Y = Math.floor(y) & 255;
            
            x -= Math.floor(x);
            y -= Math.floor(y);
            
            const u = fade(x);
            const v = fade(y);
            
            const A = perm[X] + Y;
            const B = perm[X + 1] + Y;
            
            return lerp(v, lerp(u, grad(perm[A], x, y), grad(perm[B], x - 1, y)),
                           lerp(u, grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1)));
        }
    };
}

// ==================== CONFIG ====================

const CONFIG = {
    chunkSize: 40,
    viewDistance: 3,
    maxDeaths: 5,
    ultimateDeaths: 3,
    playerSpeed: 12,
    playerRunSpeed: 20,
    jumpForce: 15,
    gravity: 35,
    colors: [0x3b82f6, 0xef4444],
    mapSize: 80,
    boundaryBuffer: 2
};

// ==================== GLOBALS ====================

let scene = null, camera = null, renderer = null;
let noise = null;
let clock = new THREE.Clock();
let chunks = new Map(), particles = [];
let players = new Map(), localPlayer = null;
let gameActive = false, myId = 0, isHost = false;
let pc = null, dc = null;
let keys = {}, mouse = { down: false, rightDown: false };

// ==================== ERROR HANDLING ====================

function showError(msg) {
    console.error(msg);
    const el = document.getElementById('error-display');
    el.innerText = msg;
    el.classList.remove('hidden');
}

window.onerror = function(msg, url, line) {
    showError('Error: ' + msg + ' (Line ' + line + ')');
};

// ==================== INITIALIZATION ====================

function init() {
    try {
        console.log('Initializing...');
        
        // Create deterministic noise
        noise = createNoise();
        console.log('Noise created');
        
        // Three.js setup
        const canvas = document.getElementById('game-canvas');
        if(!canvas) throw new Error('Canvas not found');
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
        console.log('Scene created');

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.shadowMap.enabled = true;
        console.log('Renderer created');

        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);
        console.log('Lights added');

        // Events
        window.addEventListener('resize', onResize);
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);
        document.addEventListener('mousedown', e => {
            if(e.button === 0) mouse.down = true;
            if(e.button === 2) mouse.rightDown = true;
        });
        document.addEventListener('mouseup', e => {
            if(e.button === 0) mouse.down = false;
            if(e.button === 2) mouse.rightDown = false;
        });
        document.addEventListener('contextmenu', e => e.preventDefault());

        console.log('‚úÖ Initialization complete');
        
    } catch(e) {
        showError('Init failed: ' + e.message);
    }
}

function onResize() {
    if(!camera || !renderer) return;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// ==================== TERRAIN ====================

function getTerrainHeight(x, z) {
    // Round to avoid floating point issues
    const rx = Math.round(x * 100) / 100;
    const rz = Math.round(z * 100) / 100;
    
    // Check boundaries
    const halfSize = CONFIG.mapSize / 2;
    if(Math.abs(rx) > halfSize || Math.abs(rz) > halfSize) {
        return -100;
    }
    
    // Use deterministic noise
    return noise.noise2D(rx * 0.02, rz * 0.02) * 5;
}

function createBoundaries() {
    const halfSize = CONFIG.mapSize / 2;
    
    // Visual boundary lines
    const lineMat = new THREE.MeshBasicMaterial({ 
        color: 0xff0000, 
        transparent: true, 
        opacity: 0.3 
    });
    
    const hLineGeo = new THREE.PlaneGeometry(CONFIG.mapSize, 2);
    const vLineGeo = new THREE.PlaneGeometry(2, CONFIG.mapSize - 4);
    
    const positions = [
        [0, 0.1, -halfSize + 1, hLineGeo],
        [0, 0.1, halfSize - 1, hLineGeo],
        [-halfSize + 1, 0.1, 0, vLineGeo],
        [halfSize - 1, 0.1, 0, vLineGeo]
    ];
    
    positions.forEach(([x, y, z, geo]) => {
        const mesh = new THREE.Mesh(geo, lineMat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.set(x, y, z);
        scene.add(mesh);
    });
    
    // Corner pillars
    const pillarGeo = new THREE.CylinderGeometry(1, 1, 15, 8);
    const pillarMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
    
    const corners = [
        [-halfSize + 2, -halfSize + 2],
        [halfSize - 2, -halfSize + 2],
        [-halfSize + 2, halfSize - 2],
        [halfSize - 2, halfSize - 2]
    ];
    
    corners.forEach(([x, z]) => {
        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        pillar.position.set(x, 7.5, z);
        pillar.castShadow = true;
        scene.add(pillar);
    });
}

function checkBoundaries(pos, radius) {
    const halfSize = CONFIG.mapSize / 2 - CONFIG.boundaryBuffer;
    let clamped = false;
    const newPos = pos.clone();
    
    if(newPos.x < -halfSize + radius) {
        newPos.x = -halfSize + radius;
        clamped = true;
    } else if(newPos.x > halfSize - radius) {
        newPos.x = halfSize - radius;
        clamped = true;
    }
    
    if(newPos.z < -halfSize + radius) {
        newPos.z = -halfSize + radius;
        clamped = true;
    } else if(newPos.z > halfSize - radius) {
        newPos.z = halfSize - radius;
        clamped = true;
    }
    
    return { position: newPos, clamped };
}

// ==================== WEBRTC ====================

const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
    ]
};

async function createHostOffer() {
    updateStatus('host', 'connecting', 'Creating...');
    
    try {
        pc = new RTCPeerConnection(iceServers);
        dc = pc.createDataChannel('game', { ordered: true });
        setupDataChannel(dc);
        
        pc.onicecandidate = (e) => {
            if(!e.candidate && pc.localDescription) {
                const offer = btoa(JSON.stringify(pc.localDescription));
                document.getElementById('host-offer').innerText = offer;
                updateStatus('host', 'connecting', 'Offer ready! Send to friend.');
                document.getElementById('create-offer-btn').disabled = true;
            }
        };
        
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
    } catch(e) {
        showError('Failed to create offer: ' + e.message);
    }
}

async function hostAcceptAnswer() {
    const answerStr = document.getElementById('host-answer-input').value.trim();
    if(!answerStr) {
        alert('Please paste answer code!');
        return;
    }
    
    try {
        const answer = JSON.parse(atob(answerStr));
        await pc.setRemoteDescription(answer);
        updateStatus('host', 'connected', 'Connected!');
        
        isHost = true;
        myId = 0;
        
        setTimeout(startGame, 500);
    } catch(e) {
        alert('Invalid answer: ' + e.message);
    }
}

async function createJoinAnswer() {
    const offerStr = document.getElementById('join-offer-input').value.trim();
    if(!offerStr) {
        alert('Please paste offer code!');
        return;
    }
    
    updateStatus('join', 'connecting', 'Creating...');
    
    try {
        const offer = JSON.parse(atob(offerStr));
        
        pc = new RTCPeerConnection(iceServers);
        pc.ondatachannel = (e) => {
            dc = e.channel;
            setupDataChannel(e.channel);
        };
        
        await pc.setRemoteDescription(offer);
        
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        pc.onicecandidate = (e) => {
            if(!e.candidate && pc.localDescription) {
                const answerStr = btoa(JSON.stringify(pc.localDescription));
                document.getElementById('join-answer').innerText = answerStr;
                document.getElementById('join-answer-box').classList.remove('hidden');
                updateStatus('join', 'connecting', 'Answer ready! Send to host.');
                waitForConnection();
            }
        };
        
    } catch(e) {
        showError('Failed: ' + e.message);
    }
}

function waitForConnection() {
    const check = setInterval(() => {
        if(dc && dc.readyState === 'open') {
            clearInterval(check);
            isHost = false;
            myId = 1;
            startGame();
        }
    }, 200);
}

function setupDataChannel(channel) {
    channel.onopen = () => {
        console.log('Data channel open!');
        updateStatus(isHost ? 'host' : 'join', 'connected', 'Connected!');
    };
    
    channel.onmessage = (e) => {
        const msg = JSON.parse(e.data);
        handleMessage(msg);
    };
}

function send(msg) {
    if(dc && dc.readyState === 'open') {
        dc.send(JSON.stringify(msg));
    }
}

// ==================== GAME ====================

function handleMessage(msg) {
    switch(msg.type) {
        case 'playerState':
            updateRemotePlayer(msg.data);
            break;
        case 'attack':
            if(msg.data.id !== myId) doRemoteAttack(msg.data.id);
            break;
        case 'damage':
            if(msg.target === myId) takeDamage(msg.damage, msg.source);
            break;
        case 'death':
            if(msg.id !== myId) handleRemoteDeath(msg.id, msg.killer);
            break;
    }
}

function startGame() {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('game-hud').classList.remove('hidden');
    
    createBoundaries();
    
    // Create both players
    createPlayer(myId, true);
    createPlayer(myId === 0 ? 1 : 0, false);
    
    gameActive = true;
    createHUD();
    animate();
}

function createPlayer(id, isLocal) {
    const color = CONFIG.colors[id];
    const group = new THREE.Group();
    
    // Body
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1.2, 0.6),
        new THREE.MeshStandardMaterial({ color: color })
    );
    body.position.y = 0.6;
    body.castShadow = true;
    group.add(body);
    
    // Head
    const head = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 0.7, 0.7),
        new THREE.MeshStandardMaterial({ color: 0xffffff })
    );
    head.position.y = 1.6;
    group.add(head);
    
    // Eyes
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeMat);
    leftEye.position.set(-0.15, 1.6, 0.4);
    group.add(leftEye);
    const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeMat);
    rightEye.position.set(0.15, 1.6, 0.4);
    group.add(rightEye);
    
    // Arms
    const armMat = new THREE.MeshStandardMaterial({ color: color });
    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), armMat);
    leftArm.position.set(-0.7, 0.8, 0);
    group.add(leftArm);
    
    const rightArmGroup = new THREE.Group();
    rightArmGroup.position.set(0.7, 1.2, 0);
    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), armMat);
    rightArm.position.set(0, -0.4, 0);
    rightArmGroup.add(rightArm);
    group.add(rightArmGroup);
    
    // Weapon
    const weapon = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 1.4, 0.1),
        new THREE.MeshStandardMaterial({ color: 0xcccccc })
    );
    weapon.position.set(0, -0.5, 0.3);
    weapon.rotation.x = Math.PI / 2;
    weapon.visible = false;
    rightArm.add(weapon);
    
    // Name tag
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('P' + (id + 1) + (isLocal ? ' (YOU)' : ''), 64, 22);
    
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
        map: new THREE.CanvasTexture(canvas) 
    }));
    sprite.position.y = 2.5;
    sprite.scale.set(2, 0.5, 1);
    group.add(sprite);
    
    scene.add(group);
    
    // Spawn at deterministic position
    const angle = id === 0 ? 0 : Math.PI;
    const dist = 15;
    const x = Math.cos(angle) * dist;
    const z = Math.sin(angle) * dist;
    const y = getTerrainHeight(x, z) + 1.1;
    
    group.position.set(x, y, z);
    
    console.log(`Player ${id} spawned at (${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)})`);
    
    const player = {
        id, mesh: group, isLocal, hp: 100, maxHp: 100,
        deaths: 0, ultimateCharge: 0, isDead: false,
        velocity: new THREE.Vector3(), speed: 0,
        isJumping: false, isAttacking: false, attackCooldown: 0,
        rightArm: rightArmGroup, weapon, color
    };
    
    players.set(id, player);
    if(isLocal) localPlayer = player;
    
    return player;
}

function createHUD() {
    const container = document.getElementById('players-hud');
    container.innerHTML = '';
    
    players.forEach(p => {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.id = 'card-' + p.id;
        card.style.borderColor = '#' + p.color.toString(16).padStart(6, '0');
        card.innerHTML = `
            <div style="font-size: 0.7rem; color: #${p.color.toString(16).padStart(6, '0')}; font-weight: bold;">
                P${p.id + 1} ${p.isLocal ? '(YOU)' : ''}
            </div>
            <div class="hp-bar">
                <div class="hp-fill" id="hp-${p.id}" style="width: 100%; background: #${p.color.toString(16).padStart(6, '0')}"></div>
            </div>
            <div class="hp-bar" style="height: 4px; margin-top: 4px;">
                <div id="ult-${p.id}" style="height: 100%; background: #fbbf24; width: 0%"></div>
            </div>
            <div style="font-size: 0.55rem; color: #ef4444; margin-top: 4px;">
                Deaths: <span id="deaths-${p.id}">0</span>/5
            </div>
        `;
        container.appendChild(card);
    });
}

function updateHUD() {
    players.forEach(p => {
        const hpBar = document.getElementById('hp-' + p.id);
        const ultBar = document.getElementById('ult-' + p.id);
        const deaths = document.getElementById('deaths-' + p.id);
        
        if(hpBar) hpBar.style.width = (p.hp / p.maxHp * 100) + '%';
        if(ultBar) ultBar.style.width = Math.min(p.ultimateCharge / CONFIG.ultimateDeaths * 100, 100) + '%';
        if(deaths) deaths.innerText = p.deaths;
        
        const card = document.getElementById('card-' + p.id);
        if(card) {
            card.style.opacity = p.isDead ? '0.4' : '1';
            if(p.ultimateCharge >= CONFIG.ultimateDeaths && p.isLocal) {
                card.style.boxShadow = '0 0 20px #fbbf24';
            } else {
                card.style.boxShadow = 'none';
            }
        }
    });
}

function generateChunk(cx, cz) {
    const key = `${cx},${cz}`;
    if(chunks.has(key)) return;

    const geometry = new THREE.PlaneGeometry(CONFIG.chunkSize, CONFIG.chunkSize, 20, 20);
    geometry.rotateX(-Math.PI / 2);
    
    const pos = geometry.attributes.position;
    for(let i = 0; i < pos.count; i++) {
        const wx = pos.getX(i) + (cx * CONFIG.chunkSize);
        const wz = pos.getZ(i) + (cz * CONFIG.chunkSize);
        pos.setY(i, getTerrainHeight(wx, wz));
    }
    geometry.computeVertexNormals();

    const mesh = new THREE.Mesh(
        geometry,
        new THREE.MeshStandardMaterial({ color: 0x3a5f0b, flatShading: true })
    );
    mesh.position.set(cx * CONFIG.chunkSize, 0, cz * CONFIG.chunkSize);
    mesh.receiveShadow = true;
    
    scene.add(mesh);
    chunks.set(key, mesh);
}

function update(dt) {
    if(!gameActive) return;
    
    if(localPlayer && !localPlayer.isDead) {
        updateLocalPlayer(dt);
    }
    
    // Camera
    if(localPlayer) {
        const target = localPlayer.mesh.position.clone();
        const offset = new THREE.Vector3(0, 12, -20).applyAxisAngle(
            new THREE.Vector3(0, 1, 0), 
            localPlayer.mesh.rotation.y
        );
        camera.position.lerp(target.add(offset), 0.1);
        camera.lookAt(localPlayer.mesh.position);
    }
    
    // Chunks
    if(localPlayer) {
        const cx = Math.floor(localPlayer.mesh.position.x / CONFIG.chunkSize);
        const cz = Math.floor(localPlayer.mesh.position.z / CONFIG.chunkSize);
        for(let x = cx - 2; x <= cx + 2; x++) {
            for(let z = cz - 2; z <= cz + 2; z++) {
                generateChunk(x, z);
            }
        }
    }
    
    // Network
    if(localPlayer && Math.random() < 0.3) {
        send({
            type: 'playerState',
            data: {
                id: myId,
                x: localPlayer.mesh.position.x,
                y: localPlayer.mesh.position.y,
                z: localPlayer.mesh.position.z,
                rot: localPlayer.mesh.rotation.y,
                hp: localPlayer.hp,
                deaths: localPlayer.deaths,
                attacking: localPlayer.isAttacking
            }
        });
    }
    
    updateHUD();
}

function updateLocalPlayer(dt) {
    const p = localPlayer;
    
    // Movement
    const targetSpeed = keys['ShiftLeft'] ? CONFIG.playerRunSpeed : CONFIG.playerSpeed;
    
    if(keys['KeyW'] || keys['ArrowUp']) {
        p.speed = Math.min(p.speed + 50 * dt, targetSpeed);
    } else if(keys['KeyS'] || keys['ArrowDown']) {
        p.speed = Math.max(p.speed - 50 * dt, -targetSpeed * 0.5);
    } else {
        p.speed = THREE.MathUtils.lerp(p.speed, 0, 10 * dt);
    }
    
    if(keys['KeyA'] || keys['ArrowLeft']) p.mesh.rotation.y += 3 * dt;
    if(keys['KeyD'] || keys['ArrowRight']) p.mesh.rotation.y -= 3 * dt;
    
    p.velocity.x = Math.sin(p.mesh.rotation.y) * p.speed;
    p.velocity.z = Math.cos(p.mesh.rotation.y) * p.speed;
    
    const newPos = p.mesh.position.clone();
    newPos.x += p.velocity.x * dt;
    newPos.z += p.velocity.z * dt;
    
    const boundaryCheck = checkBoundaries(newPos, 0.5);
    p.mesh.position.x = boundaryCheck.position.x;
    p.mesh.position.z = boundaryCheck.position.z;
    
    if(boundaryCheck.clamped) p.speed *= 0.5;
    
    // Physics
    const groundH = getTerrainHeight(p.mesh.position.x, p.mesh.position.z);
    
    if(p.mesh.position.y < groundH - 10) {
        // Fell through, respawn
        p.mesh.position.y = groundH + 10;
        p.velocity.y = 0;
    }
    
    if(keys['Space'] && !p.isJumping) {
        p.velocity.y = CONFIG.jumpForce;
        p.isJumping = true;
    }
    
    if(p.isJumping) {
        p.velocity.y -= CONFIG.gravity * dt;
        p.mesh.position.y += p.velocity.y * dt;
        if(p.mesh.position.y <= groundH + 1.1) {
            p.mesh.position.y = groundH + 1.1;
            p.isJumping = false;
            p.velocity.y = 0;
        }
    } else {
        p.mesh.position.y = groundH + 1.1;
    }
    
    // Combat
    if(p.attackCooldown > 0) p.attackCooldown -= dt;
    
    if((keys['KeyF'] || mouse.down) && p.attackCooldown <= 0 && !p.isAttacking) {
        doAttack();
        keys['KeyF'] = false;
        mouse.down = false;
    }
    
    if((keys['KeyG'] || mouse.rightDown) && p.ultimateCharge >= CONFIG.ultimateDeaths) {
        doUltimate();
        keys['KeyG'] = false;
        mouse.rightDown = false;
    }
    
    // Animation
    if(Math.abs(p.speed) > 1) {
        const time = Date.now() * 0.01;
        p.mesh.children[2].rotation.x = Math.sin(time) * 0.5;
        if(!p.isAttacking) {
            p.rightArm.rotation.x = Math.sin(time + Math.PI) * 0.5;
        }
    } else if(!p.isAttacking) {
        p.rightArm.rotation.x = THREE.MathUtils.lerp(p.rightArm.rotation.x, 0, dt * 10);
    }
}

function doAttack() {
    const p = localPlayer;
    p.isAttacking = true;
    p.attackCooldown = 0.4;
    p.weapon.visible = true;
    
    let swing = 0;
    const anim = setInterval(() => {
        swing += 0.4;
        p.rightArm.rotation.x = -Math.PI / 2 + Math.sin(swing) * 0.5;
        if(swing > Math.PI) {
            clearInterval(anim);
            p.isAttacking = false;
            p.weapon.visible = false;
            p.rightArm.rotation.x = 0;
        }
    }, 16);
    
    send({ type: 'attack', data: { id: myId } });
    
    const otherId = myId === 0 ? 1 : 0;
    const other = players.get(otherId);
    if(other && !other.isDead) {
        const dist = p.mesh.position.distanceTo(other.mesh.position);
        if(dist < 3) {
            const toOther = new THREE.Vector3().subVectors(other.mesh.position, p.mesh.position).normalize();
            const facing = new THREE.Vector3(Math.sin(p.mesh.rotation.y), 0, Math.cos(p.mesh.rotation.y));
            if(facing.dot(toOther) > 0.3) {
                send({ type: 'damage', target: otherId, damage: 20, source: myId });
            }
        }
    }
}

function doRemoteAttack(id) {
    const p = players.get(id);
    if(!p) return;
    
    p.isAttacking = true;
    p.weapon.visible = true;
    
    setTimeout(() => {
        p.isAttacking = false;
        p.weapon.visible = false;
        p.rightArm.rotation.x = 0;
    }, 400);
}

function doUltimate() {
    const p = localPlayer;
    p.ultimateCharge = 0;
    
    send({ type: 'attack', data: { id: myId, ultimate: true } });
    
    const otherId = myId === 0 ? 1 : 0;
    const other = players.get(otherId);
    if(other && !other.isDead) {
        const dist = p.mesh.position.distanceTo(other.mesh.position);
        if(dist < 10) {
            send({ type: 'damage', target: otherId, damage: 40, source: myId });
        }
    }
    
    addKillFeed('P' + (myId + 1) + ' used ULTIMATE! ‚ö°');
}

function takeDamage(damage, source) {
    const p = localPlayer;
    p.hp -= damage;
    
    p.mesh.children[0].material.emissive.setHex(0xff0000);
    p.mesh.children[0].material.emissiveIntensity = 0.8;
    setTimeout(() => {
        p.mesh.children[0].material.emissive.setHex(0x000000);
        p.mesh.children[0].material.emissiveIntensity = 0;
    }, 100);
    
    if(p.hp <= 0) die(source);
}

function die(killerId) {
    const p = localPlayer;
    p.deaths++;
    p.ultimateCharge = Math.min(p.ultimateCharge + 1, CONFIG.ultimateDeaths);
    
    send({ type: 'death', id: myId, killer: killerId });
    
    addKillFeed('P' + (killerId + 1) + ' killed P' + (myId + 1) + '!');
    
    if(p.deaths >= CONFIG.maxDeaths) {
        p.isDead = true;
        p.mesh.visible = false;
        addKillFeed('P' + (myId + 1) + ' ELIMINATED! üíÄ');
        checkWinner();
    } else {
        setTimeout(() => {
            p.hp = p.maxHp;
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 20;
            const x = Math.cos(angle) * dist;
            const z = Math.sin(angle) * dist;
            const y = getTerrainHeight(x, z);
            p.mesh.position.set(x, y + 1.1, z);
            p.mesh.visible = true;
        }, 2000);
    }
}

function handleRemoteDeath(id, killerId) {
    const p = players.get(id);
    if(!p) return;
    
    p.deaths++;
    addKillFeed('P' + (killerId + 1) + ' killed P' + (id + 1) + '!');
    
    if(p.deaths >= CONFIG.maxDeaths) {
        p.isDead = true;
        p.mesh.visible = false;
        addKillFeed('P' + (id + 1) + ' ELIMINATED! üíÄ');
        checkWinner();
    }
}

function checkWinner() {
    const alive = Array.from(players.values()).filter(p => !p.isDead);
    if(alive.length === 1) {
        gameActive = false;
        setTimeout(() => {
            document.getElementById('game-hud').classList.add('hidden');
            document.getElementById('game-over').classList.remove('hidden');
            const winner = alive[0];
            document.getElementById('winner-title').innerText = 'P' + (winner.id + 1) + ' WINS!';
            document.getElementById('winner-title').style.color = '#' + winner.color.toString(16).padStart(6, '0');
            document.getElementById('winner-subtitle').innerText = winner.isLocal ? 'Victory!' : 'Defeat!';
        }, 1000);
    }
}

function updateRemotePlayer(data) {
    const p = players.get(data.id);
    if(!p || p.isLocal) return;
    
    // CRITICAL: Recalculate Y based on local terrain for perfect sync
    const correctY = getTerrainHeight(data.x, data.z) + 1.1;
    
    p.mesh.position.set(data.x, correctY, data.z);
    p.mesh.rotation.y = data.rot;
    p.hp = data.hp;
    p.deaths = data.deaths;
    
    if(data.attacking) {
        p.weapon.visible = true;
        p.rightArm.rotation.x = -Math.PI / 2;
    } else {
        p.weapon.visible = false;
        p.rightArm.rotation.x = 0;
    }
}

function addKillFeed(msg) {
    const feed = document.getElementById('kill-feed');
    const el = document.createElement('div');
    el.className = 'kill-msg';
    el.innerHTML = msg;
    feed.appendChild(el);
    if(feed.children.length > 5) feed.removeChild(feed.firstChild);
    setTimeout(() => el.remove(), 4000);
}

function animate() {
    requestAnimationFrame(animate);
    update(clock.getDelta());
    if(renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

// ==================== UI ====================

function startHost() {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('host-screen').classList.remove('hidden');
}

function startJoin() {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('join-screen').classList.remove('hidden');
}

function backToMenu() {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('menu-screen').classList.remove('hidden');
}

function updateStatus(type, state, text) {
    const dot = document.getElementById(type + '-status-dot');
    const txt = document.getElementById(type + '-status-text');
    
    dot.className = 'status-dot ' + (state === 'connected' ? 'connected' : state === 'connecting' ? 'connecting' : '');
    txt.innerText = text;
}

function copyText(el) {
    navigator.clipboard.writeText(el.innerText).then(() => {
        el.style.background = '#1a3a1a';
        setTimeout(() => el.style.background = '#000', 200);
    });
}

// Start
window.onload = function() {
    console.log('Window loaded, starting init...');
    init();
};

</script>
</body>
</html>