<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Arena - P2P Battle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Press Start 2P', cursive; 
            background: #0a0a0a;
            color: white;
            overflow: hidden;
        }
        
        #game-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        
        .screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f23 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 20px;
        }
        
        .hidden { display: none !important; }
        
        .title {
            font-size: 3rem;
            color: #fbbf24;
            text-shadow: 0 0 20px #fbbf24, 4px 4px 0 #000;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            color: #60a5fa;
            font-size: 0.7rem;
            margin-bottom: 40px;
            text-align: center;
            line-height: 2;
        }
        
        .btn {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #000;
            border: none;
            padding: 20px 40px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            margin: 10px;
            border-radius: 10px;
            box-shadow: 0 6px 0 #92400e, 0 0 20px rgba(251, 191, 36, 0.5);
            transition: all 0.1s;
            font-weight: bold;
        }
        
        .btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 8px 0 #92400e, 0 0 30px rgba(251, 191, 36, 0.8);
        }
        .btn:active { 
            transform: translateY(4px); 
            box-shadow: 0 2px 0 #92400e, 0 0 20px rgba(251, 191, 36, 0.5);
        }
        .btn.secondary { 
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            box-shadow: 0 6px 0 #1e40af, 0 0 20px rgba(59, 130, 246, 0.5);
        }
        .btn.secondary:active { box-shadow: 0 2px 0 #1e40af, 0 0 20px rgba(59, 130, 246, 0.5); }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .step-box {
            background: rgba(0,0,0,0.6);
            border: 2px solid #60a5fa;
            border-radius: 15px;
            padding: 25px;
            max-width: 700px;
            width: 100%;
            margin: 15px 0;
        }
        
        .step-number {
            display: inline-block;
            width: 30px; height: 30px;
            background: #fbbf24;
            color: #000;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            font-size: 0.8rem;
            margin-right: 10px;
        }
        
        .code-box {
            background: #000;
            border: 2px solid #22c55e;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.6rem;
            color: #22c55e;
            word-break: break-all;
            max-height: 120px;
            overflow-y: auto;
            margin: 15px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .code-box:hover {
            border-color: #4ade80;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
        }
        
        .code-input {
            width: 100%;
            background: #000;
            border: 2px solid #60a5fa;
            border-radius: 10px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.6rem;
            color: #fff;
            min-height: 120px;
            resize: vertical;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            font-size: 0.7rem;
        }
        
        .status-dot {
            width: 12px; height: 12px;
            border-radius: 50%;
            background: #ef4444;
        }
        .status-dot.connecting { background: #fbbf24; animation: blink 1s infinite; }
        .status-dot.connected { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
        
        .players-hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            z-index: 10;
            pointer-events: none;
        }
        
        .player-card {
            background: rgba(0,0,0,0.85);
            border: 3px solid;
            border-radius: 12px;
            padding: 12px 18px;
            min-width: 160px;
        }
        
        .hp-bar {
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 8px;
        }
        .hp-fill { height: 100%; transition: width 0.2s; }
        
        .ult-bar {
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 6px;
        }
        .ult-fill {
            height: 100%;
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            width: 0%;
            transition: width 0.3s;
        }
        
        .kill-feed {
            position: fixed;
            top: 140px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        
        .kill-msg {
            background: rgba(0,0,0,0.9);
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 0.65rem;
            border-left: 4px solid #ef4444;
            animation: slideIn 0.4s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 0.6rem;
            text-align: center;
            line-height: 1.8;
            z-index: 10;
        }
        
        .copy-hint {
            color: #22c55e;
            font-size: 0.6rem;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <!-- MAIN MENU -->
    <div id="menu-screen" class="screen">
        <div class="title">‚öîÔ∏è VOXEL ARENA</div>
        <div class="subtitle">
            P2P MULTIPLAYER BATTLE<br>
            No server needed - Direct connection<br>
            2 Players ‚Ä¢ 5 Deaths = Elimination ‚Ä¢ 3 Deaths = Ultimate
        </div>
        <button class="btn" onclick="startHost()">üéÆ HOST GAME</button>
        <button class="btn secondary" onclick="startJoin()">üöÄ JOIN GAME</button>
    </div>

    <!-- HOST SCREEN -->
    <div id="host-screen" class="screen hidden">
        <div class="title" style="font-size: 2rem;">HOST GAME</div>
        
        <div class="step-box">
            <div style="margin-bottom: 15px;">
                <span class="step-number">1</span>
                <span style="color: #fbbf24;">Copy this OFFER code and send to friend:</span>
            </div>
            <div class="code-box" id="host-offer" onclick="copyToClipboard(this)">
                Click "CREATE OFFER" to generate code...
            </div>
            <div class="copy-hint">üëÜ Click to copy</div>
            <button class="btn" id="create-offer-btn" onclick="createHostOffer()">CREATE OFFER</button>
        </div>
        
        <div class="step-box">
            <div style="margin-bottom: 15px;">
                <span class="step-number">2</span>
                <span style="color: #fbbf24;">Paste friend's ANSWER code here:</span>
            </div>
            <textarea class="code-input" id="host-answer-input" placeholder="Paste answer code here..."></textarea>
            <button class="btn" onclick="hostAcceptAnswer()">CONNECT & START</button>
        </div>
        
        <div class="status">
            <div class="status-dot" id="host-status-dot"></div>
            <span id="host-status-text">Waiting...</span>
        </div>
        
        <button class="btn secondary" onclick="backToMenu()" style="margin-top: 20px;">BACK</button>
    </div>

    <!-- JOIN SCREEN -->
    <div id="join-screen" class="screen hidden">
        <div class="title" style="font-size: 2rem;">JOIN GAME</div>
        
        <div class="step-box">
            <div style="margin-bottom: 15px;">
                <span class="step-number">1</span>
                <span style="color: #60a5fa;">Paste host's OFFER code:</span>
            </div>
            <textarea class="code-input" id="join-offer-input" placeholder="Paste offer code here..."></textarea>
            <button class="btn" onclick="createJoinAnswer()">CREATE ANSWER</button>
        </div>
        
        <div class="step-box hidden" id="join-answer-box">
            <div style="margin-bottom: 15px;">
                <span class="step-number">2</span>
                <span style="color: #22c55e;">Copy this ANSWER code and send to host:</span>
            </div>
            <div class="code-box" id="join-answer" onclick="copyToClipboard(this)">
                Generating...
            </div>
            <div class="copy-hint">üëÜ Click to copy, then wait for host to connect...</div>
        </div>
        
        <div class="status">
            <div class="status-dot" id="join-status-dot"></div>
            <span id="join-status-text">Enter offer code</span>
        </div>
        
        <button class="btn secondary" onclick="backToMenu()" style="margin-top: 20px;">BACK</button>
    </div>

    <!-- GAME HUD -->
    <div id="game-hud" class="hidden">
        <div class="players-hud" id="players-hud"></div>
        <div class="kill-feed" id="kill-feed"></div>
        <div class="controls-hint">
            <span style="color: #fbbf24;">WASD</span> = Move | 
            <span style="color: #fbbf24;">SPACE</span> = Jump | 
            <span style="color: #ef4444;">F / CLICK</span> = Attack | 
            <span style="color: #fbbf24;">G / RIGHT-CLICK</span> = Ultimate
        </div>
    </div>

    <!-- GAME OVER -->
    <div id="game-over" class="screen hidden">
        <div class="title" id="winner-title">VICTORY!</div>
        <div class="subtitle" id="winner-subtitle" style="color: #fbbf24; font-size: 1.2rem;">Player Wins!</div>
        <button class="btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

<script>
/**
 * WORKING P2P MULTIPLAYER WITH MANUAL SIGNALING
 */

// Game Config
const CONFIG = {
    chunkSize: 40,
    viewDistance: 3,
    maxDeaths: 5,
    ultimateDeaths: 3,
    playerSpeed: 12,
    playerRunSpeed: 20,
    jumpForce: 15,
    gravity: 35,
    colors: [0x3b82f6, 0xef4444]
};

// Globals
let scene, camera, renderer, simplex = new SimplexNoise();
let clock = new THREE.Clock();
let chunks = new Map(), particles = [];
let players = new Map(), localPlayer = null;
let gameActive = false, myId = 0, isHost = false;

// WebRTC
let pc = null, dc = null;
const keys = {}, mouse = { down: false, rightDown: false };

// Initialize Three.js
function init() {
    try {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('game-canvas'), 
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Events
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);
        document.addEventListener('mousedown', e => {
            if(e.button === 0) mouse.down = true;
            if(e.button === 2) mouse.rightDown = true;
        });
        document.addEventListener('mouseup', e => {
            if(e.button === 0) mouse.down = false;
            if(e.button === 2) mouse.rightDown = false;
        });
        document.addEventListener('contextmenu', e => e.preventDefault());

        console.log('‚úÖ Game initialized');
    } catch(e) {
        alert('Failed to initialize: ' + e.message);
    }
}

// ==================== WEBRTC SIGNALING ====================

const iceServers = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
    ]
};

// HOST: Create offer
async function createHostOffer() {
    updateHostStatus('connecting', 'Creating offer...');
    
    pc = new RTCPeerConnection(iceServers);
    
    dc = pc.createDataChannel('game', { ordered: true });
    setupDataChannel(dc);
    
    pc.onicecandidate = (e) => {
        if(!e.candidate) {
            // All candidates gathered
            const offer = btoa(JSON.stringify(pc.localDescription));
            document.getElementById('host-offer').innerText = offer;
            updateHostStatus('connecting', 'Offer created! Send to friend.');
            document.getElementById('create-offer-btn').disabled = true;
        }
    };
    
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
}

// HOST: Accept answer
async function hostAcceptAnswer() {
    const answerStr = document.getElementById('host-answer-input').value.trim();
    if(!answerStr) {
        alert('Please paste answer code!');
        return;
    }
    
    try {
        const answer = JSON.parse(atob(answerStr));
        await pc.setRemoteDescription(answer);
        updateHostStatus('connected', 'Connected! Starting game...');
        
        isHost = true;
        myId = 0;
        
        setTimeout(startGame, 500);
    } catch(e) {
        alert('Invalid answer code: ' + e.message);
    }
}

// JOIN: Create answer
async function createJoinAnswer() {
    const offerStr = document.getElementById('join-offer-input').value.trim();
    if(!offerStr) {
        alert('Please paste offer code!');
        return;
    }
    
    updateJoinStatus('connecting', 'Creating answer...');
    
    try {
        const offer = JSON.parse(atob(offerStr));
        
        pc = new RTCPeerConnection(iceServers);
        
        pc.ondatachannel = (e) => {
            dc = e.channel;
            setupDataChannel(dc);
        };
        
        await pc.setRemoteDescription(offer);
        
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        pc.onicecandidate = (e) => {
            if(!e.candidate) {
                const answerStr = btoa(JSON.stringify(pc.localDescription));
                document.getElementById('join-answer').innerText = answerStr;
                document.getElementById('join-answer-box').classList.remove('hidden');
                updateJoinStatus('connecting', 'Answer created! Send to host and wait...');
                
                // Wait for connection
                waitForConnection();
            }
        };
        
    } catch(e) {
        alert('Failed: ' + e.message);
        updateJoinStatus('error', 'Failed to create answer');
    }
}

function waitForConnection() {
    const check = setInterval(() => {
        if(dc && dc.readyState === 'open') {
            clearInterval(check);
            isHost = false;
            myId = 1;
            startGame();
        }
    }, 100);
}

function setupDataChannel(channel) {
    channel.onopen = () => {
        console.log('üéÆ Data channel OPEN!');
        updateHostStatus('connected', 'Connected!');
        updateJoinStatus('connected', 'Connected!');
    };
    
    channel.onmessage = (e) => {
        const msg = JSON.parse(e.data);
        handleMessage(msg);
    };
    
    channel.onclose = () => console.log('Channel closed');
    channel.onerror = (e) => console.error('Channel error:', e);
}

function send(msg) {
    if(dc && dc.readyState === 'open') {
        dc.send(JSON.stringify(msg));
    }
}

// ==================== GAME ====================

function handleMessage(msg) {
    switch(msg.type) {
        case 'playerState':
            updateRemotePlayer(msg.data);
            break;
        case 'attack':
            handleRemoteAttack(msg);
            break;
        case 'damage':
            if(msg.target === myId) takeDamage(msg.damage, msg.source);
            break;
        case 'death':
            handleRemoteDeath(msg.id, msg.killer);
            break;
    }
}

function startGame() {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('game-hud').classList.remove('hidden');
    
    // Create players
    createPlayer(myId, true); // Local
    
    const otherId = myId === 0 ? 1 : 0;
    createPlayer(otherId, false); // Remote
    
    gameActive = true;
    createHUD();
    animate();
}

function createPlayer(id, isLocal) {
    const group = new THREE.Group();
    const color = CONFIG.colors[id];
    
    // Body
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1.2, 0.6),
        new THREE.MeshStandardMaterial({ color: color })
    );
    body.position.y = 0.6;
    body.castShadow = true;
    group.add(body);
    
    // Head
    const head = new THREE.Mesh(
        new THREE.BoxGeometry(0.7, 0.7, 0.7),
        new THREE.MeshStandardMaterial({ color: 0xffffff })
    );
    head.position.y = 1.6;
    group.add(head);
    
    // Eyes
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const leftEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeMat);
    leftEye.position.set(-0.15, 1.6, 0.4);
    group.add(leftEye);
    const rightEye = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.1), eyeMat);
    rightEye.position.set(0.15, 1.6, 0.4);
    group.add(rightEye);
    
    // Arms
    const armMat = new THREE.MeshStandardMaterial({ color: color });
    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), armMat);
    leftArm.position.set(-0.7, 0.8, 0);
    group.add(leftArm);
    
    const rightArmGroup = new THREE.Group();
    rightArmGroup.position.set(0.7, 1.2, 0);
    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.25), armMat);
    rightArm.position.set(0, -0.4, 0);
    rightArmGroup.add(rightArm);
    group.add(rightArmGroup);
    
    // Weapon
    const weapon = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 1.4, 0.1),
        new THREE.MeshStandardMaterial({ color: 0xcccccc })
    );
    weapon.position.set(0, -0.5, 0.3);
    weapon.rotation.x = Math.PI / 2;
    weapon.visible = false;
    rightArm.add(weapon);
    
    // Name tag
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('P' + (id + 1) + (isLocal ? ' (YOU)' : ''), 64, 22);
    
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ 
        map: new THREE.CanvasTexture(canvas) 
    }));
    sprite.position.y = 2.5;
    sprite.scale.set(2, 0.5, 1);
    group.add(sprite);
    
    scene.add(group);
    
    // Spawn position
    const angle = id === 0 ? 0 : Math.PI;
    group.position.set(Math.cos(angle) * 15, 10, Math.sin(angle) * 15);
    
    const player = {
        id, mesh: group, isLocal, hp: 100, maxHp: 100,
        deaths: 0, ultimateCharge: 0, isDead: false,
        velocity: new THREE.Vector3(), speed: 0,
        isJumping: false, isAttacking: false, attackCooldown: 0,
        rightArm: rightArmGroup, weapon, color
    };
    
    players.set(id, player);
    if(isLocal) localPlayer = player;
    
    return player;
}

function createHUD() {
    const container = document.getElementById('players-hud');
    container.innerHTML = '';
    
    players.forEach(p => {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.id = 'card-' + p.id;
        card.style.borderColor = '#' + p.color.toString(16).padStart(6, '0');
        card.innerHTML = `
            <div style="font-size: 0.75rem; color: #${p.color.toString(16).padStart(6, '0')}; font-weight: bold;">
                P${p.id + 1} ${p.isLocal ? '(YOU)' : ''}
            </div>
            <div class="hp-bar">
                <div class="hp-fill" id="hp-${p.id}" style="width: 100%; background: #${p.color.toString(16).padStart(6, '0')}"></div>
            </div>
            <div class="ult-bar">
                <div class="ult-fill" id="ult-${p.id}"></div>
            </div>
            <div style="font-size: 0.6rem; color: #ef4444; margin-top: 6px;">
                üíÄ <span id="deaths-${p.id}">0</span>/5
            </div>
        `;
        container.appendChild(card);
    });
}

function updateHUD() {
    players.forEach(p => {
        const hpBar = document.getElementById('hp-' + p.id);
        const ultBar = document.getElementById('ult-' + p.id);
        const deaths = document.getElementById('deaths-' + p.id);
        
        if(hpBar) hpBar.style.width = (p.hp / p.maxHp * 100) + '%';
        if(ultBar) ultBar.style.width = Math.min(p.ultimateCharge / CONFIG.ultimateDeaths * 100, 100) + '%';
        if(deaths) deaths.innerText = p.deaths;
        
        const card = document.getElementById('card-' + p.id);
        if(card) {
            if(p.isDead) card.style.opacity = '0.4';
            else card.style.opacity = '1';
            
            if(p.ultimateCharge >= CONFIG.ultimateDeaths && p.isLocal) {
                card.style.boxShadow = '0 0 30px #fbbf24';
            } else {
                card.style.boxShadow = 'none';
            }
        }
    });
}

function getTerrainHeight(x, z) {
    return simplex.noise2D(x * 0.02, z * 0.02) * 5;
}

function generateChunk(cx, cz) {
    const key = `${cx},${cz}`;
    if(chunks.has(key)) return;

    const geometry = new THREE.PlaneGeometry(CONFIG.chunkSize, CONFIG.chunkSize, 20, 20);
    geometry.rotateX(-Math.PI / 2);
    
    const pos = geometry.attributes.position;
    for(let i = 0; i < pos.count; i++) {
        const wx = pos.getX(i) + (cx * CONFIG.chunkSize);
        const wz = pos.getZ(i) + (cz * CONFIG.chunkSize);
        pos.setY(i, getTerrainHeight(wx, wz));
    }
    geometry.computeVertexNormals();

    const mesh = new THREE.Mesh(
        geometry,
        new THREE.MeshStandardMaterial({ color: 0x3a5f0b, flatShading: true })
    );
    mesh.position.set(cx * CONFIG.chunkSize, 0, cz * CONFIG.chunkSize);
    mesh.receiveShadow = true;
    
    scene.add(mesh);
    chunks.set(key, mesh);
}

function update(dt) {
    if(!gameActive) return;
    
    // Update local
    if(localPlayer && !localPlayer.isDead) {
        updateLocalPlayer(dt);
    }
    
    // Camera
    if(localPlayer) {
        const target = localPlayer.mesh.position.clone();
        const offset = new THREE.Vector3(0, 12, -20).applyAxisAngle(
            new THREE.Vector3(0, 1, 0), 
            localPlayer.mesh.rotation.y
        );
        camera.position.lerp(target.add(offset), 0.1);
        camera.lookAt(localPlayer.mesh.position);
    }
    
    // Chunks
    if(localPlayer) {
        const cx = Math.floor(localPlayer.mesh.position.x / CONFIG.chunkSize);
        const cz = Math.floor(localPlayer.mesh.position.z / CONFIG.chunkSize);
        for(let x = cx - 2; x <= cx + 2; x++) {
            for(let z = cz - 2; z <= cz + 2; z++) {
                generateChunk(x, z);
            }
        }
    }
    
    // Network sync
    if(localPlayer && Math.random() < 0.3) {
        send({
            type: 'playerState',
            data: {
                id: myId,
                x: localPlayer.mesh.position.x,
                y: localPlayer.mesh.position.y,
                z: localPlayer.mesh.position.z,
                rot: localPlayer.mesh.rotation.y,
                hp: localPlayer.hp,
                deaths: localPlayer.deaths,
                attacking: localPlayer.isAttacking
            }
        });
    }
    
    updateHUD();
}

function updateLocalPlayer(dt) {
    const p = localPlayer;
    
    // Move
    const targetSpeed = keys['ShiftLeft'] ? CONFIG.playerRunSpeed : CONFIG.playerSpeed;
    
    if(keys['KeyW'] || keys['ArrowUp']) {
        p.speed = Math.min(p.speed + 50 * dt, targetSpeed);
    } else if(keys['KeyS'] || keys['ArrowDown']) {
        p.speed = Math.max(p.speed - 50 * dt, -targetSpeed * 0.5);
    } else {
        p.speed = THREE.MathUtils.lerp(p.speed, 0, 10 * dt);
    }
    
    if(keys['KeyA'] || keys['ArrowLeft']) p.mesh.rotation.y += 3 * dt;
    if(keys['KeyD'] || keys['ArrowRight']) p.mesh.rotation.y -= 3 * dt;
    
    p.velocity.x = Math.sin(p.mesh.rotation.y) * p.speed;
    p.velocity.z = Math.cos(p.mesh.rotation.y) * p.speed;
    
    p.mesh.position.x += p.velocity.x * dt;
    p.mesh.position.z += p.velocity.z * dt;
    
    // Physics
    const groundH = getTerrainHeight(p.mesh.position.x, p.mesh.position.z);
    
    if((keys['Space']) && !p.isJumping) {
        p.velocity.y = CONFIG.jumpForce;
        p.isJumping = true;
    }
    
    if(p.isJumping) {
        p.velocity.y -= CONFIG.gravity * dt;
        p.mesh.position.y += p.velocity.y * dt;
        if(p.mesh.position.y <= groundH + 1.1) {
            p.mesh.position.y = groundH + 1.1;
            p.isJumping = false;
            p.velocity.y = 0;
        }
    } else {
        p.mesh.position.y = groundH + 1.1;
    }
    
    // Combat
    if(p.attackCooldown > 0) p.attackCooldown -= dt;
    
    if((keys['KeyF'] || mouse.down) && p.attackCooldown <= 0 && !p.isAttacking) {
        doAttack();
        keys['KeyF'] = false;
        mouse.down = false;
    }
    
    if((keys['KeyG'] || mouse.rightDown) && p.ultimateCharge >= CONFIG.ultimateDeaths) {
        doUltimate();
        keys['KeyG'] = false;
        mouse.rightDown = false;
    }
    
    // Animate
    if(Math.abs(p.speed) > 1) {
        const time = Date.now() * 0.01;
        p.mesh.children[2].rotation.x = Math.sin(time) * 0.5;
        if(!p.isAttacking) {
            p.rightArm.rotation.x = Math.sin(time + Math.PI) * 0.5;
        }
    } else if(!p.isAttacking) {
        p.rightArm.rotation.x = THREE.MathUtils.lerp(p.rightArm.rotation.x, 0, dt * 10);
    }
}

function doAttack() {
    const p = localPlayer;
    p.isAttacking = true;
    p.attackCooldown = 0.4;
    p.weapon.visible = true;
    
    // Swing
    let swing = 0;
    const anim = setInterval(() => {
        swing += 0.4;
        p.rightArm.rotation.x = -Math.PI / 2 + Math.sin(swing) * 0.5;
        if(swing > Math.PI) {
            clearInterval(anim);
            p.isAttacking = false;
            p.weapon.visible = false;
            p.rightArm.rotation.x = 0;
        }
    }, 16);
    
    send({ type: 'attack', data: { id: myId } });
    
    // Hit check
    const otherId = myId === 0 ? 1 : 0;
    const other = players.get(otherId);
    if(other && !other.isDead) {
        const dist = p.mesh.position.distanceTo(other.mesh.position);
        if(dist < 3) {
            const toOther = new THREE.Vector3().subVectors(other.mesh.position, p.mesh.position).normalize();
            const facing = new THREE.Vector3(Math.sin(p.mesh.rotation.y), 0, Math.cos(p.mesh.rotation.y));
            if(facing.dot(toOther) > 0.3) {
                send({ type: 'damage', target: otherId, damage: 20, source: myId });
            }
        }
    }
}

function doUltimate() {
    const p = localPlayer;
    p.ultimateCharge = 0;
    
    send({ type: 'attack', data: { id: myId, ultimate: true } });
    
    // AOE
    const otherId = myId === 0 ? 1 : 0;
    const other = players.get(otherId);
    if(other && !other.isDead) {
        const dist = p.mesh.position.distanceTo(other.mesh.position);
        if(dist < 10) {
            send({ type: 'damage', target: otherId, damage: 40, source: myId });
        }
    }
    
    addKillFeed('P' + (myId + 1) + ' used ULTIMATE! ‚ö°');
}

function takeDamage(damage, source) {
    const p = localPlayer;
    p.hp -= damage;
    
    // Flash
    p.mesh.children[0].material.emissive.setHex(0xff0000);
    p.mesh.children[0].material.emissiveIntensity = 0.8;
    setTimeout(() => {
        p.mesh.children[0].material.emissive.setHex(0x000000);
        p.mesh.children[0].material.emissiveIntensity = 0;
    }, 100);
    
    if(p.hp <= 0) {
        die(source);
    }
}

function die(killerId) {
    const p = localPlayer;
    p.deaths++;
    p.ultimateCharge = Math.min(p.ultimateCharge + 1, CONFIG.ultimateDeaths);
    
    send({ type: 'death', id: myId, killer: killerId });
    
    addKillFeed('P' + (killerId + 1) + ' killed P' + (myId + 1) + '!');
    
    if(p.deaths >= CONFIG.maxDeaths) {
        p.isDead = true;
        p.mesh.visible = false;
        addKillFeed('P' + (myId + 1) + ' ELIMINATED! üíÄ');
        checkWinner();
    } else {
        // Respawn
        setTimeout(() => {
            p.hp = p.maxHp;
            const angle = Math.random() * Math.PI * 2;
            p.mesh.position.set(Math.cos(angle) * 25, 15, Math.sin(angle) * 25);
            p.mesh.visible = true;
        }, 2000);
    }
}

function handleRemoteDeath(id, killerId) {
    const p = players.get(id);
    if(!p) return;
    
    p.deaths++;
    addKillFeed('P' + (killerId + 1) + ' killed P' + (id + 1) + '!');
    
    if(p.deaths >= CONFIG.maxDeaths) {
        p.isDead = true;
        p.mesh.visible = false;
        addKillFeed('P' + (id + 1) + ' ELIMINATED! üíÄ');
        checkWinner();
    }
}

function checkWinner() {
    const alive = Array.from(players.values()).filter(p => !p.isDead);
    if(alive.length === 1) {
        gameActive = false;
        setTimeout(() => {
            document.getElementById('game-hud').classList.add('hidden');
            document.getElementById('game-over').classList.remove('hidden');
            const winner = alive[0];
            document.getElementById('winner-title').innerText = 'P' + (winner.id + 1) + ' WINS!';
            document.getElementById('winner-title').style.color = '#' + winner.color.toString(16).padStart(6, '0');
            document.getElementById('winner-subtitle').innerText = winner.isLocal ? 'Victory!' : 'Defeat!';
        }, 1000);
    }
}

function updateRemotePlayer(data) {
    const p = players.get(data.id);
    if(!p || p.isLocal) return;
    
    p.mesh.position.set(data.x, data.y, data.z);
    p.mesh.rotation.y = data.rot;
    p.hp = data.hp;
    p.deaths = data.deaths;
    
    if(data.attacking) {
        p.weapon.visible = true;
        p.rightArm.rotation.x = -Math.PI / 2;
    } else {
        p.weapon.visible = false;
        p.rightArm.rotation.x = 0;
    }
}

function addKillFeed(msg) {
    const feed = document.getElementById('kill-feed');
    const el = document.createElement('div');
    el.className = 'kill-msg';
    el.innerHTML = msg;
    feed.appendChild(el);
    if(feed.children.length > 5) feed.removeChild(feed.firstChild);
    setTimeout(() => el.remove(), 4000);
}

function animate() {
    requestAnimationFrame(animate);
    update(clock.getDelta());
    renderer.render(scene, camera);
}

// ==================== UI HELPERS ====================

function startHost() {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('host-screen').classList.remove('hidden');
}

function startJoin() {
    document.getElementById('menu-screen').classList.add('hidden');
    document.getElementById('join-screen').classList.remove('hidden');
}

function backToMenu() {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('menu-screen').classList.remove('hidden');
}

function updateHostStatus(type, text) {
    const dot = document.getElementById('host-status-dot');
    dot.className = 'status-dot ' + (type === 'connected' ? 'connected' : type === 'connecting' ? 'connecting' : '');
    document.getElementById('host-status-text').innerText = text;
}

function updateJoinStatus(type, text) {
    const dot = document.getElementById('join-status-dot');
    dot.className = 'status-dot ' + (type === 'connected' ? 'connected' : type === 'connecting' ? 'connecting' : '');
    document.getElementById('join-status-text').innerText = text;
}

function copyToClipboard(el) {
    navigator.clipboard.writeText(el.innerText).then(() => {
        el.style.background = '#1a3a1a';
        setTimeout(() => el.style.background = '#000', 200);
    });
}

// Start
init();

</script>
</body>
</html>